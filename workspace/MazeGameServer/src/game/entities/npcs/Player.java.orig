package game.entities.npcs;

import java.util.ArrayList;

import engine.Vector2f;
import engine.physics.RigidBody;
import game.Inventory;
import game.MazeGameServer;
import game.enums.*;
import game.environment.Interior;
import game.environment.Room;
import game.entities.EntityFactory;

/*
* Classname:            Player.java
*
* Version information:  1.0
*
* Date:                 10/30/2013
*
* Copyright notice:     Copyright (c) 2013 Garrett Benoit
*/

/**
 * Player:
 */
public class Player extends Hostile {
    private static final int MAX_HEALTH = 28;
    private static final int BLASTER_DAMAGE = 1;
    private static final int ATTACK_RANGE = 168;
    private static final float SPEED = 0.8f;
    private static final int MAX_PROJECTILES = 5;
    private static final long MAX_INVUNERABLE_TIME = 1000;
    private static final long SHOOT_INTERVAL = 300;
    private long shootTime = 0;
    private boolean shootPressed = false;
    private float speedRatio = 0.0f; // between 0 and 1
    private int playerID = 0;
    private int lives = 3;
    private boolean shielded = false;
    private long invulnerableTime = 0;
    private boolean invulnerable = true;
    private Hostage follower = null;
    private Inventory inventory = new Inventory();
    
    public Player(RigidBody rb, int playerID, Room room, Face dir) {
        super(playerID == 0 ? AnimationPath.PLAYER_1 : playerID == 1 ? AnimationPath.PLAYER_2 :
            playerID == 2 ? AnimationPath.PLAYER_3 : AnimationPath.PLAYER_4, rb, room, dir);
        this.playerID = playerID;
        range = ATTACK_RANGE;
        damage = BLASTER_DAMAGE;
        health = MAX_HEALTH;
    }
    
    public Inventory getInventory(){
        return inventory;
    }
    
    public int getPlayerID() {
        return playerID;
    }
    
    public void reset() {
        health = MAX_HEALTH;
        facing = Face.DOWN;
        invulnerable = true;
        invulnerableTime = 0;
        dead = false;
        shielded = false;
        follower = null;
        speedRatio = 0.0f;
        shootTime = 0;
        shootPressed = false;
        enable();
<<<<<<< HEAD
=======
        isDying = 0;
        isDead = false;
        rBody.setLocation(MazeGameServer.level.getExterior().getPlayerSpawns().get(playerID));
    }
    
    public void spawn(int frames) {  
        if(spawned == false){
            imageIndex = imageIndex + 20; 
            if(imageIndex >= frames*100) {
                imageIndex = 0;
            }
            int test = imageIndex/100;
            image = animationPath+spawnArray[test];
            if(image.equals(animationPath+"spawn5.gif")){
                spawned = true;
            }
        }
    }
    
    public void animateMovement(Move direction){
        imageIndex = imageIndex + 10; 
        if(imageIndex >= imgArraySize*100 && (isFire || shotTimer >= 10)) {
            imageIndex = 0;
        }
        if(!isFire && shotTimer >= 10){
            switch (direction) {
                case RIGHT:
                    image = animationPath+runningRightArray[imageIndex/100];
                    imgArraySize = runningRightArray.length;
                    break;
                case LEFT:
                    image = animationPath+runningLeftArray[imageIndex/100];
                    imgArraySize = runningLeftArray.length;
                    break;
                case UP:
                    image = animationPath+runningUpArray[imageIndex/100];
                    imgArraySize = runningUpArray.length;
                    break;
                case DOWN:
                    image = animationPath+runningDownArray[imageIndex/100];
                    imgArraySize = runningDownArray.length;
                    break;
            }
        }
        else if(isFire) {
            switch (direction) {
                case RIGHT:
                    image = animationPath+runningRightShootArray[imageIndex/100];
                    imgArraySize = runningRightShootArray.length;
                    break;
                case LEFT:
                    image = animationPath+runningLeftShootArray[imageIndex/100];
                    imgArraySize = runningLeftShootArray.length;
                    break;
                case UP:
                    image = animationPath+runningUpArray[imageIndex/100];
                    imgArraySize = runningUpArray.length;
                    break;
                case DOWN:
                    image = animationPath+runningDownArray[imageIndex/100];
                    imgArraySize = runningDownArray.length;
                    break;
            }
        }
>>>>>>> f6f34c7ff6943717ece5738a0534ce8594d33391
    }
    
    /**
     * fire: shoot a bullet
     */
    public void fire() {
        //GameEngine.playSound(game.sound_shot);
        room.addProjectile(EntityFactory.createProjectile(rBody.getLocation(), null, facing, this, ProjectileType.STRAIGHT));
    }
    
    @Override
    public void update(long elapsedTime) {
        if(!dead) {
            faceMouse(MazeGameServer.mice.get(playerID));
            handleItemInputs(MazeGameServer.inputs.get(playerID));
            handleMoveInputs(MazeGameServer.inputs.get(playerID), elapsedTime);
            handleFireInputs(MazeGameServer.inputs.get(playerID), elapsedTime);
            
            if(invulnerable) {
                invulnerableTime += elapsedTime;
                if(invulnerableTime > MAX_INVUNERABLE_TIME) {
                    invulnerableTime = 0;
                    invulnerable = false;
                }
            }
        }
    }
    
    public void faceMouse(Vector2f loc) {
        if(room instanceof Interior) {
            Interior interior = (Interior) room;
            loc.addEq(new Vector2f(interior.getCenter()));
            loc.subEq(rBody.getLocation());
        }
        if(Math.abs(loc.y) > Math.abs(loc.x)) {
            // Up or Down
            if(loc.y > 0) {
                facing = Face.DOWN;
            } else {
                facing = Face.UP;
            }
        } else {
            // Right or Left
            if(loc.x > 0) {
                facing = Face.RIGHT;
            } else {
                facing = Face.LEFT;
            }
        }
    }
    
    @Override
    public void takeDamage(int d) {
<<<<<<< HEAD
        if (!invulnerable) {
            if (shielded) {
                //GameEngine.playSound(game.sound_hit_shield);
                shielded = false;
            }
            else {
                //GameEngine.playSound(game.sound_hit);
                setHealth(getHealth()-0);
                invulnerable = true;
=======
        if(isDamage == 0 && isVuln){
            //GameEngine.playSound(game.sound_hit);
            setHealthPoints(getHealthPoints()-d);
            if(getShield()){//if have shield, take shield away
                setShield(false);
            }else{
                System.out.println(this.getInventory().getItem().toString());
                setHealthPoints(getHealthPoints()-0);//for testing purpose
>>>>>>> f6f34c7ff6943717ece5738a0534ce8594d33391
            }
        }
        if(getHealth() == 0 && !dead) {
            //GameEngine.playSound(game.sound_dead);
            dead = true;
        }
    }
    
    public void handleMoveInputs(ArrayList<Boolean> inputs, long elapsedTime) {
        float moveX = 0.0f;
        float moveY = 0.0f;
        float speed = SPEED * speedRatio;
        if (inputs.get(Pressed.RIGHT.getValue())) {
            moveX += speed;
        }
        if (inputs.get(Pressed.LEFT.getValue())) {
            moveX -= speed;
        }
        if (inputs.get(Pressed.UP.getValue())) {
            moveY -= speed;
        }
        if (inputs.get(Pressed.DOWN.getValue())) {
            moveY += speed;
        }
        
        if(moveX != 0 || moveY != 0) {
            if(speedRatio == 0.0f) speedRatio = 0.25f;
            if(speedRatio < 1.0f) speedRatio += 0.15f * speedRatio;//Math.min((float)Math.sqrt((double) speedRatio), 1.0f);
        }
        else {
            if(speedRatio <= 0.05f) speedRatio = 0.0f;
            if(speedRatio > 0.0f) speedRatio -= speedRatio * 0.2f;//Math.max(1.0f-(float)Math.sqrt((double) 1.0f-speedRatio), 0.0f);
            speed = SPEED * speedRatio;
            if(rBody.getDelta().x > 0.0f) moveX += speed;
            else if(rBody.getDelta().x < 0.0f) moveX -= speed;
            if(rBody.getDelta().y > 0.0f) moveY += speed;
            else if(rBody.getDelta().y < 0.0f) moveY -= speed;
            if(speedRatio == 0.0f) speedRatio = 0.25f;
            if(speedRatio < 1.0f) speedRatio += 0.15f * speedRatio;//Math.min((float)Math.sqrt((double) speedRatio), 1.0f);
        }

        if(speedRatio <= 0.25f) {
            animState = AnimationState.IDLE;
        } else {
            animState = AnimationState.RUN;
        }
        
        rBody.move(moveX, moveY, elapsedTime);
    }
    
    public void handleFireInputs(ArrayList<Boolean> inputs, long elapsedTime) {
        shootTime += elapsedTime;
        if (inputs.get(Pressed.FIRE.getValue()) && !shootPressed) {
            if(numProjectiles < MAX_PROJECTILES && shootTime > SHOOT_INTERVAL){
                fire();
                shootTime = 0;
            }
            shootPressed = false;
        } else if(!inputs.get(Pressed.FIRE.getValue())) {
            shootPressed = false;
        }
    }
    
<<<<<<< HEAD
    public void handleItemInputs(ArrayList<Boolean> inputs) {
        if (inputs.get(Pressed.SELECT_FORWARD.getValue())) {
            this.getInventory().selectNextItem();
        }
        if (inputs.get(Pressed.SELECT_BACKWARD.getValue())) {
            this.getInventory().selectPrevItem();
        }
        if (inputs.get(Pressed.USE_ITEM.getValue())) {
            this.getInventory().useSelectedItem(this);
        }
=======
    private boolean pressedUse=false, pressedBackward=false, pressedForward = false;
    public void handleItems(ArrayList<Boolean> inputs){
            if(inputs.get(Pressed.SELECT_FORWARD.getValue()) && !pressedForward){
                pressedForward = true;
                this.getInventory().selectNextItem();
            }else if(!inputs.get(Pressed.SELECT_FORWARD.getValue())) {
                pressedForward = false;
            }
            
            
            if(inputs.get(Pressed.SELECT_BACKWARD.getValue()) && !pressedBackward){
                pressedBackward = true;
                this.getInventory().selectPrevItem();
            }else if(!inputs.get(Pressed.SELECT_BACKWARD.getValue())) {
                pressedBackward = false;
            }
            
            if(inputs.get(Pressed.USE_ITEM.getValue()) && !pressedUse){
                pressedUse = true;
                this.getInventory().useSelectedItem(this, room);
            } else if(!inputs.get(Pressed.USE_ITEM.getValue())) {
                pressedUse = false;
            }
>>>>>>> f6f34c7ff6943717ece5738a0534ce8594d33391
    }
    
    public int getLives() {
        return lives;
    }
    
    public void addLife() {
        lives++;
    }
    
    public void removeLife() {
        lives--;
    }
    
    public void setFollower(Hostage hostage) {
        follower = hostage;
    }
    
    public Hostage getFollower() {
        return follower;
    }
    
    public boolean hasFollower() {
        if(follower != null) {
            return true;
        }
        return false;
    }
    
    public boolean getShield(){
        return shielded;
    }
    
    public void addShield(){
        this.shielded = true;
    }
}
