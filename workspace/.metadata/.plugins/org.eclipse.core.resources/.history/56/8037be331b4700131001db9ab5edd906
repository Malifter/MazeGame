package game;
import java.util.ArrayList;
import java.util.Random;

import engine.SerializedObject;
import engine.physics.Collisions;

/*
* Classname:            Gatekeeper.java
*
* Version information:  1.0
*
* Date:                 11/6/2013
*
* Copyright notice:     Copyright (c) 2013 Garrett Benoit
*/

/**
 * Gatekeeper activates a portal if given the appropriate items
 */
public class Gatekeeper extends Entity {
    private Room room;
    private Portal portal;
    
    /**
     * This will change
     * Constructor: <add description>
     * @param g - instance of the game - will be removed later
     * @param image - image of the gatekeeper
     * @param iX - image location
     * @param iY
     * @param x - finds center of solid body
     * @param y
     * @param w - width and height of solid body
     * @param h
     * @param room - room it's spawned in
     */
    public Gatekeeper(Game g, String image, int iX, int iY, int x, int y, int w, int h, Room room, Portal portal) {
        super(g, image, iX, iY, w, h);
        game = (MazeGameServer) g;
        minX = x;
        minY = y;
        width = w;
        height = h;
        offsetX = Math.abs(imageX - minX);
        offsetY = Math.abs(imageY - minY);
        calculateBounds();
        this.room = room;
        this.portal = portal;
    }
    
    @Override
    public void update(long time) {
        // Here we'd animate the idle animation
        
        // Don't worry about this for now,
        // I'll try to create an Animator class
        // or you can try to code it like how it's done
        // in in the Player class.
        
        // You would have to use images we already have
        // unless you wan't to find some online.
        
        // Potentially in the future if a gatekeeper
        // has some dynamic physics that causes them
        // to be moved by the player or by an explosion
        // maybe they can be updated to move back to their
        // original position and face direction
        // this is not needed for now
    }
    
    public void movements(long time) {
        // find closest player
        Entity player = null;
        float minDist = 99999; // tmp replace later
        for(Entity p: room.getPlayers()) {
            float dist = Collisions.findDistance(p, this);
            if(dist < minDist) {
                minDist = dist;
                player = p;
            }
        }
        if(player == null) return;
        if(Math.abs(player.getMidX()-midX) < AGGRO_RANGE && Math.abs(player.getMidY()-midY) < AGGRO_RANGE) {
            if(player.getMidX()-midX > 0) {
                facingRight = true;
            }
            else {
                facingRight = false;
            }
            if(true/*!isFalling*/) {/*
                if (player.getIsJumping() && !isJump) {
                    velY = 3;
                    if(facingRight) {
                        velX = 1;
                    }
                    else {
                        velX = -1;
                    }
                    move((int) (velX * (time / moveFactor)), -(int) (velY * (time / moveFactor)));
                    setIsFalling(true);
                    isJump = true;
                }
                else if(!player.getIsJumping() && isJump) {
                    isJump = false;
                }*/
                if(facingRight) {
                    velX = 1;
                }
                else {
                    velX = -1;
                }
                move((int) (velX * (time / moveFactor)), -(int) (velY * (time / moveFactor)));
            }
            Random generator = new Random( GameEngine.getTime() );
            int rand = generator.nextInt() % 100;
            if ((rand >= 80 && numBullets <= 0) || GameEngine.getTime() - lastShotTime > 2000) {
                if(GameEngine.getTime() - lastShotTime > 200){
                    fire(facingRight);
                    numBullets++;
                }
                isFire = true;
                shotTimer = 0;
            }
        }

        imageIndex = imageIndex + 10;
        if(imageIndex >= 200) {
            imageIndex = 0;
        }
        if(player.getMidX()-midX > 0) {
            facingRight = true;
            if(shotTimer >= 15) {
                image = imageArrayRight[imageIndex/100];     
            }
        }
        else {
            facingRight = false;
            if(shotTimer >= 15) {
                image = imageArray[imageIndex/100];
            }
        }/*
        if(isFalling) {
            velY = velY - (gravity*(time/1000.0f));
            move((int) (velX * (time / moveFactor)), -(int) (velY * (time / moveFactor)));
            //image = "shieldguyJump.gif";
        }
        if(isFalling && isJump) {
            if(facingRight && shotTimer >= 15) {
                image = "\\enemies\\woodman3Right.gif";
            }
            else if(!facingRight && shotTimer >= 15) {
                image = "\\enemies\\woodman3.gif";
            }
        }*/
        if(isFire){
            isFire = false;
            if(facingRight) {
                image = "\\enemies\\woodman4Right.gif";
            }
            else if(!facingRight) {
                image = "\\enemies\\woodman4.gif";
            }
        }
        shotTimer++;
    }
}
